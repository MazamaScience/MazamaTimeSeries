% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mts_combine.R
\name{mts_combine}
\alias{mts_combine}
\title{Combine multiple \code{mts} objects}
\usage{
mts_combine(...)
}
\arguments{
\item{...}{Any number of valid \emph{mts} objects.}
}
\value{
A combined \code{mts} object.
}
\description{
Create a combined \emph{mts} from any number of \emph{mts}
objects or from a list of \emph{mts} objects. The resulting \emph{mts}
object with contain all \code{deviceDeploymentIDs} found in any incoming
\emph{mts} and will have a regular time axis covering the the entire range
of incoming data.

If incoming time ranges are non-contiguous, the resulting \emph{mts} will
have gaps filled with \code{NA} values.

An error is generated if the incoming \emph{mts} objects have
non-identical metadata for the same \code{deviceDeploymentID}.
}
\note{
Data are combined with a "latest is best" sensibility where any
data overlaps exist. Incoming \emph{mts} objects are ordered based on the
time stamp of their last record. Then \code{dplyr::distinct()} is used to
remove records with duplicate \code{datetime} fields. Any data records found
in "later" \emph{mts} objects are preferentially retained before the data
are finally reordered by ascending \code{datetime}.
}
\examples{
library(MazamaTimeSeries)

ids1 <- example_mts$meta$deviceDeploymentID[1:5]
ids2 <- example_mts$meta$deviceDeploymentID[4:6]
ids3 <- example_mts$meta$deviceDeploymentID[8:10]

mts1 <-
  example_mts \%>\%
  mts_filterMeta(deviceDeploymentID \%in\% ids1) \%>\%
  mts_filterDate(20190701, 20190703)

mts2 <-
  example_mts \%>\%
  mts_filterMeta(deviceDeploymentID \%in\% ids2) \%>\%
  mts_filterDate(20190704, 20190706)

mts3 <-
  example_mts \%>\%
  mts_filterMeta(deviceDeploymentID \%in\% ids3) \%>\%
  mts_filterDate(20190705, 20190708)

mts <- mts_combine(mts1, mts2, mts3)

# Should have 1:6 + 8:10 = 9 meta records and the full date range
nrow(mts$meta)
range(mts$data$datetime)

}
